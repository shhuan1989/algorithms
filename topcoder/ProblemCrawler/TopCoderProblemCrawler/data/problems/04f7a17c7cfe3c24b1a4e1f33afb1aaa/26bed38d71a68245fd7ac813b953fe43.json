{
	"link":"http://community.topcoder.com/stat?c=problem_statement&pm=179&rd=51",
	"statement":"<pre>Class Name: FSM\nMethod Name: runFSM\nParamaters: String String String[]\nReturns String[]\n\nImplement a class FSM, which contains a method runFSM.  The method runs an\naugmented finite state machine:\n\nThe augmented finite state machine consists of a number of states.  Each state\nhas a unique name of type String.  There are edges connecting the states.\nThese edges are directional: they go in only one direction, their source state\nto their sink state (source and sink states are described below).  Each edge\nhas a corresponding symbol and function that are both represented as Strings.\n\nHere is the method signature (be sure your method is public):\nString[] runFSM(String symbols, String states, String[] edges)\n\nInput:\n*symbols - The first parameter to runFSM is a String containing elements\nreferred to as symbols that will be passed to the FSM.  The elements/symbols\nwill contain letters only (A-Z and a-z, inclusive).  Each element of the\nsymbols input parameter is separated by one or more spaces.\n\n*states - The second parameter to runFSM is a String containing elements that\nrefer to the names of the states.  The names/states will contain letters (A-Z\nand a-z, inclusive) only.  The first state in this list is the starting state.\nEach element of the states input parameter is separated by one or more spaces.\n\n*edges[] - The third parameter is a String[].  Each element in the String[]\ndescribes an edge.  The Strings in the array will contain four sets of letters,\nwhere the sets are separated by one or more spaces.  Parsing the String from\nthe left-most character moving right, the first set of letters is the source\nstate - the state in which the edge starts.  The second set of letters is the\nsink state - the state in which the edge ends.  The third set of letters is the\nsymbol corresponding to the edge.  The fourth set of letters is the function\ncorresponding with the edge.\n\nOutput:\nThe output is a String[] containing a list of all the functions called with\ntheir associated symbols as parameters, in order.  There should be only one\nelement in the output for each symbol in the first input String.\n\nThe augmented finite state machine is passed a sequence of symbols.  Each\nsymbol is processed as follows:\n1.  Use the first state (the first element of the states String) as the source\nstate and let that equal the current state.\n2.  Determine the first symbol (i.e. the first element of the symbols String)\nlet that equal the current symbol.\n3.  Find the edge of the current state that corresponds to the current symbol.\n4.  Add a String to the output array.  The String should consist of the\nfunction name of the edge found in step 3 with the current symbol enclosed in\nparentheses (i.e. if the function is &quot;open&quot; and the symbol is &quot;hi&quot;, the\nfunction call is &quot;open(hi)&quot;).\n5.  Move to the sink state that corresponds with the current symbol.\n6.  Let current state be equal to the sink state from step 5\n7.  Repeat steps 3 - 6 for the remaining symbols.\n\nNote:\n* If ever there is no edge leaving the current state with the current symbol,\nadd the String &quot;ERROR&quot; to the output array, remain at the current state, and go\non to the next symbol.\n* No two edges may contain the same source state and symbol.\n* All String comparisons are case sensitive.\n* The output is a list of the function calls created in step four (above) in\norder.\n* The sink state can be equal to the source state\n* There may be additional spaces at the beginning or end of any input String.\n\nTopCoder will ensure:\n- All the Strings and elements of arrays will contain letters (A-Z and a-z,\ninclusive) and spaces (' ') only.\n- The states mentioned in the edges array will be present in the states String.\n- symbols will contain at least one element.\n- states will contain at least one element.\n- symbols and states will have length between 1 and 50, inclusive.\n- edges will contain between 1 and 50 elements, inclusive, and each element\nwill contain between 1 and 50 characters, inclusive.\n- No two edges will have the same source state and symbol\n- Elements of the edges array will be well formed.  That is, each element will\nbe in the form: &quot;(source state) (sink) (state symbol) (function)&quot; (the\nparentheses are for clarity and should not be included in the String).  There\nwill be exactly four elements separated by one or more spaces\n\n\nExamples:\nExample relating to a vending machine that releases candy every time 20 cents\nis put in, assume:\nstates=&quot;Zerocents Fivecents Tencents Fifteencents Twentycents&quot;\nand\nedges={\n&quot;Zerocents  Fivecents  nickel needMoreOne&quot;,\n&quot;Zerocents  Tencents dime   needMoreTwo&quot;,\n&quot;Fivecents  Fifteencents dime   needMoreThree&quot;,\n&quot;Fivecents  Tencents nickel needMoreFour&quot;,\n&quot;Tencents Fifteencents nickel needMoreFive&quot;,\n&quot;Tencents Twentycents dime   releasingCandyOne&quot;,\n&quot;Fifteencents Twentycents nickel releasingCandyTwo&quot;,\n&quot;Fifteencents Twentycents dime   releasingCandyThree&quot;,\n&quot;Twentycents Fivecents  nickel needMoreSix&quot;,\n&quot;Twentycents Tencents dime   needMoreSeven&quot;\n}\n\nIf symbols=&quot;nickel dime dime&quot;, the output should be:\n{&quot;needMoreOne(nickel)&quot;,\n &quot;needMoreThree(dime)&quot;,\n &quot;releasingCandyThree(dime)&quot;}\n\nIf symbols=&quot;dime oops dime&quot; the output should be\n{&quot;needMoreTwo(dime)&quot;,\n &quot;ERROR&quot;,\n &quot;releasingCandyOne(dime)&quot;}\n\nIf symbols=&quot;dime nickel dime dime dime nickel&quot; the output should be\n{&quot;needMoreTwo(dime)&quot;,\n &quot;needMoreFive(nickel)&quot;,\n &quot;releasingCandyThree(dime)&quot;,\n &quot;needMoreSeven(dime)&quot;,\n &quot;releasingCandyOne(dime),\n &quot;needMoreSix(nickel)}\n\nMore Examples:\nIf symbols=&quot; a   a  a b  b   c&quot; and\nstates=&quot; stateZero stateOne stateTwo&quot;\nand edges=\n{&quot;stateZero stateOne a doSomething&quot;,\n &quot;stateOne stateTwo b doNothing&quot;,\n &quot;stateTwo stateZero c doEverything&quot;}\n\nThe output should be\n{&quot;doSomething(a)&quot;,\n &quot;ERROR&quot;,\n &quot;ERROR&quot;,\n &quot;doNothing(b)&quot;,\n &quot;ERROR&quot;,\n &quot;doEverything(c)&quot;}\n</pre>",
	"notes":[],
	"definition":[
		{
			"definitionKey":"Class:",
			"definitionVal":"FSM",
			"order":1
		},
		{
			"definitionKey":"Method:",
			"definitionVal":"runFSM",
			"order":2
		},
		{
			"definitionKey":"Parameters:",
			"definitionVal":"String, String, String[]",
			"order":3
		},
		{
			"definitionKey":"Returns:",
			"definitionVal":"String[]",
			"order":4
		},
		{
			"definitionKey":"Method signature:",
			"definitionVal":"String[] runFSM(String param0, String param1, String[] param2)",
			"order":5
		}
	],
	"examples":[],
	"constraints":[]
}