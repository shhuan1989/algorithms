{
	"link":"http://community.topcoder.com/stat?c=problem_statement&pm=1131&rd=4370",
	"statement":"<p> We all know that there are not necessarily three dimensions, and that there are wormholes scattered throughout the universe which will transport you through time and space. However, because it is often difficult for people to conceptualize higher dimensions, we will probably have to have computers do most of our navigation for us. Your task is to write a program that will simulate a pseudo-random asteroid field, and then navigate a ship through the asteroid field as quickly as possible. </p> <p> The first step will be to generate the asteroid field. You will be given a int[], <b>dim</b>, that will specify how large you should make each dimension in your asteroid field. For example, if <b>dim</b> is {3,4,5}, the generated asteroid field will be a 3 x 4 x 5 box, with corners at (0,0,0) and (2,3,4). If <b>dim</b> is {3,4,5,4}, the generated asteroid field will be a 3 x 4 x 5 x 4 hyper-box (a hyper box is analogous to a regular box, but in more than three dimensions). Then, you must determine which spaces in the asteroid field actually contain asteroids. This will be done pseudo-randomly using something like the following code, where <b>a</b> and <b>p</b> are inputs (remember that there are a variable number of dimensions): </p> <pre>\nint current = 1;\nfor(int i<sub>0</sub> = 0; i<sub>0</sub>&lt;dim<sub>0</sub>; i<sub>0</sub>++)\nfor(int i<sub>1</sub> = 0; i<sub>1</sub>&lt;dim<sub>1</sub>; i<sub>1</sub>++)\n... one loop per dimension\n{\n    current = (current*a)%p;\n    if((current&amp;1)==1){\n        //add an asteroid at (i<sub>0</sub>,i<sub>1</sub>,i<sub>2</sub>,...)\n    }\n}\n</pre> <p> Once the asteroid field is generated, you have to navigate through it. You will be given a int[], <b>start</b>, and a int[], <b>finish</b>. You must find your way through the asteroid field, as quickly as possible without running into an asteroid. You may move from any location (a<sub>0</sub>,a<sub>1</sub>,a<sub>2</sub>...) to any other location, (b<sub>0</sub>,b<sub>1</sub>,b<sub>2</sub>...) so long as for all i, the differences between a<sub>i</sub> and b<sub>i</sub> is either 1 or 0, and b<sub>i</sub> is between 0 and dim<sub>i</sub>-1, inclusive. Each such movement takes one unit of time. For example, if you were at the S below, you could move to any of the locations marked with T, where '.' represents open space. </p> <pre>\n.....\n.TTT.\n.TST.\n.TTT.\n.....\n</pre> <p> In addition to this type of movement, you may also (but are not required to) travel through wormholes. You will be given a String[], <b>wormholes</b>, which specifies the origin, length of time travel, and destination of some wormholes. To go through a wormhole, you must first reach the origin of the wormhole. Then, after going through the wormhole, you will be transported to the destination of the wormhole. Additionally, wormholes transport you in time. So, each wormhole has a fixed amount of time travel associated with it, and each time you go through the wormhole, you will go forward or backward in time by that amount. Each element of <b>wormholes</b> will be formatted as &quot;&lt;origin&gt; &lt;time&gt; &lt;destination&gt;&quot;, where &lt;origin&gt; and &lt;destination&gt; and coordinates as a space delimited list. For example, &quot;0 0 -1 3 7&quot; would represent a wormhole that starts at (0,0), transports you back in time 1 unit, and leaves you at (3,7) in space. Thus, if you reached (0,0) 5 units of time after you started, it would be possible to reach (3,7) from there 4 units of time after you started. </p><p> Sometimes, it will be impossible to reach <b>finish</b> from <b>start</b>. In this case return, 2^31-1 = 2147483647. </p>",
	"notes":[],
	"definition":[
		{
			"definitionKey":"Class:",
			"definitionVal":"HigherMaze",
			"order":1
		},
		{
			"definitionKey":"Method:",
			"definitionVal":"navigate",
			"order":2
		},
		{
			"definitionKey":"Parameters:",
			"definitionVal":"int, int, int[], int[], int[], String[]",
			"order":3
		},
		{
			"definitionKey":"Returns:",
			"definitionVal":"int",
			"order":4
		},
		{
			"definitionKey":"Method signature:",
			"definitionVal":"int navigate(int a, int p, int[] dim, int[] start, int[] finish, String[] wormholes)",
			"order":5
		}
	],
	"examples":[
		{
			"expect":"193",
			"id":0,
			"input":"138",
			"note":"This input generates the following two dimensional asteroid field, where an 'X' is an asteroid, and a '.' is open space. (Here, (0,0) is the upper left corner, and (4,4) is the lower right, and (4,0) is in the lower left):  Here is one path that takes 6 time units, where 'S' represents the start, 'F' the finish, and '*' the path.  ",
			"order":1
		},
		{
			"expect":"193",
			"id":0,
			"input":"138",
			"note":"While there is still a path from (0,0) to (4,4) which takes 6 time units, there is also a wormhole, which transports you directly from (0,0) to (4,4), and ahead 2 units of time.",
			"order":2
		},
		{
			"expect":"193",
			"id":0,
			"input":"138",
			"note":"This is the same asteroid configuration as the previous two examples, but now there are more wormholes. The quickest way to get from (0,0) to (4,4) is to move from from (0,0) to (0,2), which takes 2 units of time. From (0,2) we should go through the wormhole to (1,4), which transports us ahead 5 units of time, for a total of 7. Then, we can take the wormhole from (1,4) to (4,4), which takes us back 8 units of time. Thus, the total time for the trip is 2 + 5 - 8 = -1, and we arrive before we left!(note that two wormholes can start at the same location, and could even start and end at the same location)",
			"order":3
		},
		{
			"expect":"73",
			"id":0,
			"input":"54",
			"order":4
		},
		{
			"expect":"193",
			"id":0,
			"input":"139",
			"note":"The only way to get all the way is to go through all 4 wormholes, in order. ",
			"order":5
		},
		{
			"expect":"193",
			"id":0,
			"input":"138",
			"order":6
		},
		{
			"expect":"193",
			"id":0,
			"input":"139",
			"order":7
		}
	],
	"constraints":[
		{
			"order":1,
			"val":"The product of all the elements of dim will be between 2 and 1000, inclusive."
		},
		{
			"order":2,
			"val":"Each element of dim will be between 2 and 20, inclusive."
		},
		{
			"order":3,
			"val":"dim will contain between 1 and 5 elements, inclusive."
		},
		{
			"order":4,
			"val":"a and p will be between 1 and 2,000,000,000, inclusive."
		},
		{
			"order":5,
			"val":"a times p will be between 1 and 2,000,000,000, inclusive."
		},
		{
			"order":6,
			"val":"start and finish will be within the hyper-box defined by dim."
		},
		{
			"order":7,
			"val":"start and finish will be both be empty space (not an asteroid, possibly a wormhole)."
		},
		{
			"order":8,
			"val":"wormholes will contain between 0 and 50 elements, inclusive."
		},
		{
			"order":9,
			"val":"Each element of wormholes will be formatted as &quot;&lt;origin&gt; &lt;time&gt; &lt;destination&gt;&quot;."
		},
		{
			"order":10,
			"val":"&lt;origin&gt; and &lt;destination&gt; will both be space delimited (no extra, leading or trailing spaces) lists of integers, representing a coordinate in space within the hyper-box defined by dim."
		},
		{
			"order":11,
			"val":"&lt;origin&gt; and &lt;destination&gt; will both be empty space (not an asteroid)."
		},
		{
			"order":12,
			"val":"&lt;time&gt; will be an integer in the range -1,000,000 to 1,000,000."
		},
		{
			"order":13,
			"val":"There will be no way to go back in time infinitely. (In other words, there will be no reachable cycles that take negative amounts of time. However, there may be unreachable ones, but they can not affect the return, since they are unreachable.)"
		}
	]
}